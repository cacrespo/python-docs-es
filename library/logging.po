# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/PyCampES/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-05 12:54+0200\n"
"PO-Revision-Date: 2020-06-11 07:35-0500\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: \n"
"Language: es\n"
"X-Generator: Poedit 2.3.1\n"

#: ../Doc/library/logging.rst:2
msgid ":mod:`logging` --- Logging facility for Python"
msgstr ":mod:`logging` --- Instalación de registradores para Python"

#: ../Doc/library/logging.rst:10
msgid "**Source code:** :source:`Lib/logging/__init__.py`"
msgstr "**Source code:** :source:`Lib/logging/__init__.py`"

#: ../Doc/library/logging.rst:16
msgid ""
"This page contains the API reference information. For tutorial information "
"and discussion of more advanced topics, see"
msgstr ""
"Esta página contiene la información de referencia de la API. Para "
"información sobre tutorial y discusión de temas más avanzados, ver"

#: ../Doc/library/logging.rst:19
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Basic Tutorial <logging-basic-tutorial>`"

#: ../Doc/library/logging.rst:20
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"

#: ../Doc/library/logging.rst:21
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`Logging Cookbook <logging-cookbook>`"

#: ../Doc/library/logging.rst:25
msgid ""
"This module defines functions and classes which implement a flexible event "
"logging system for applications and libraries."
msgstr ""
"Este módulo define funciones y clases que implementan un sistema flexible de "
"registro de eventos para aplicaciones y bibliotecas."

#: ../Doc/library/logging.rst:28
msgid ""
"The key benefit of having the logging API provided by a standard library "
"module is that all Python modules can participate in logging, so your "
"application log can include your own messages integrated with messages from "
"third-party modules."
msgstr ""
"El beneficio clave de tener la API de registro proporcionada por un módulo "
"de biblioteca estándar es que todos los módulos de Python pueden participar "
"en el registro, por lo que el registro de su aplicación puede incluir sus "
"propios mensajes integrados con mensajes de módulos de terceros."

#: ../Doc/library/logging.rst:33
msgid ""
"The module provides a lot of functionality and flexibility.  If you are "
"unfamiliar with logging, the best way to get to grips with it is to see the "
"tutorials (see the links on the right)."
msgstr ""
"El módulo proporciona mucha funcionalidad y flexibilidad. Si no está "
"familiarizado con el registro, la mejor manera de familiarizarse con él es "
"ver los tutoriales (ver los enlaces a la derecha)."

#: ../Doc/library/logging.rst:37
msgid ""
"The basic classes defined by the module, together with their functions, are "
"listed below."
msgstr ""
"Las clases básicas definidas por el módulo, junto con sus funciones, se "
"enumeran a continuación."

#: ../Doc/library/logging.rst:40
msgid "Loggers expose the interface that application code directly uses."
msgstr ""
"Los registradores exponen la interfaz que el código de la aplicación usa "
"directamente."

#: ../Doc/library/logging.rst:41
msgid ""
"Handlers send the log records (created by loggers) to the appropriate "
"destination."
msgstr ""
"Los controladores envían los registros (creados por los registradores) al "
"destino apropiado."

#: ../Doc/library/logging.rst:43
msgid ""
"Filters provide a finer grained facility for determining which log records "
"to output."
msgstr ""
"Los filtros proporcionan una facilidad de ajuste preciso para determinar que "
"registros generar."

#: ../Doc/library/logging.rst:45
msgid "Formatters specify the layout of log records in the final output."
msgstr ""
"Los formateadores especifican el diseño de los registros en el resultado "
"final."

#: ../Doc/library/logging.rst:51
msgid "Logger Objects"
msgstr "Objetos de Registradores"

#: ../Doc/library/logging.rst:53
msgid ""
"Loggers have the following attributes and methods.  Note that Loggers should "
"*NEVER* be instantiated directly, but always through the module-level "
"function ``logging.getLogger(name)``.  Multiple calls to :func:`getLogger` "
"with the same name will always return a reference to the same Logger object."
msgstr ""
"Los registradores tienen los siguientes atributos y métodos. Tenga en cuenta "
"que los registradores deben ``NEVER`` ser instanciados directamente, pero "
"siempre a través de la función de nivel de módulo ``logging.getLogger "
"(nombre)``. Múltiples llamadas a :func:`getLogger` con el mismo nombre "
"siempre devolverán una referencia al mismo objeto ``Logger``."

#: ../Doc/library/logging.rst:58
msgid ""
"The ``name`` is potentially a period-separated hierarchical value, like "
"``foo.bar.baz`` (though it could also be just plain ``foo``, for example). "
"Loggers that are further down in the hierarchical list are children of "
"loggers higher up in the list.  For example, given a logger with a name of "
"``foo``, loggers with names of ``foo.bar``, ``foo.bar.baz``, and ``foo.bam`` "
"are all descendants of ``foo``.  The logger name hierarchy is analogous to "
"the Python package hierarchy, and identical to it if you organise your "
"loggers on a per-module basis using the recommended construction ``logging."
"getLogger(__name__)``.  That's because in a module, ``__name__`` is the "
"module's name in the Python package namespace."
msgstr ""
"El ``nombre`` es potencialmente un valor jerárquico separado por puntos, "
"como ``foo.bar.baz`` (aunque también podría ser simplemente ```foo``, por "
"ejemplo). Los registradores que están más abajo en la lista jerárquica son "
"hijos de los registradores que están más arriba en la lista. Por ejemplo, "
"dado un registrador con el nombre de ``foo``, los registradores con los "
"nombres de ``foo.bar``, ``foo.bar.baz`` y ``foo.bam`` son descendientes de "
"``foo``. La jerarquía del nombre del registrador es análoga a la jerarquía "
"del paquete Python e idéntica si organiza los registradores por módulo "
"utilizando la construcción recomendada ``logging.getLogger(__name__)``. "
"Debido que en un módulo, ``__name__`` el nombre del módulo es el mismo que "
"el de espacio de nombres del paquete Python."

#: ../Doc/library/logging.rst:74
msgid ""
"If this attribute evaluates to true, events logged to this logger will be "
"passed to the handlers of higher level (ancestor) loggers, in addition to "
"any handlers attached to this logger. Messages are passed directly to the "
"ancestor loggers' handlers - neither the level nor filters of the ancestor "
"loggers in question are considered."
msgstr ""
"Si este atributo se evalúa como verdadero, los eventos registrados en este "
"registrador se pasarán a los registros de los registradores de nivel "
"superior (ancestro), además de los controladores asociados a este "
"registrador. Los mensajes se pasan directamente a los manejadores de los "
"registradores ancestrales; no se consideran ni el nivel ni los filtros de "
"los registradores ancestrales en cuestión."

#: ../Doc/library/logging.rst:80
msgid ""
"If this evaluates to false, logging messages are not passed to the handlers "
"of ancestor loggers."
msgstr ""
"Si esto se evalúa como falso, los mensajes de registro no se pasan a los "
"controladores de los registradores ancestrales."

#: ../Doc/library/logging.rst:83
msgid "The constructor sets this attribute to ``True``."
msgstr "La constructora establece este atributo en verdadero."

#: ../Doc/library/logging.rst:85
msgid ""
"If you attach a handler to a logger *and* one or more of its ancestors, it "
"may emit the same record multiple times. In general, you should not need to "
"attach a handler to more than one logger - if you just attach it to the "
"appropriate logger which is highest in the logger hierarchy, then it will "
"see all events logged by all descendant loggers, provided that their "
"propagate setting is left set to ``True``. A common scenario is to attach "
"handlers only to the root logger, and to let propagation take care of the "
"rest."
msgstr ""
"Si adjunta un controlador a un registrador ``and`` uno o más de sus "
"antepasados, puede emitir el mismo registro varias veces. En general, no "
"debería necesitar adjuntar un controlador a más de un registrador; si solo "
"lo adjunta al registrador apropiado que está más arriba en la jerarquía del "
"registrador, verá todos los eventos registrados por todos los registradores "
"descendientes, siempre que la configuración de propagación sea `` True``. Un "
"escenario común es adjuntar controladores solo al registrador raíz y dejar "
"que la propagación se encargue del resto."

#: ../Doc/library/logging.rst:96
msgid ""
"Sets the threshold for this logger to *level*. Logging messages which are "
"less severe than *level* will be ignored; logging messages which have "
"severity *level* or higher will be emitted by whichever handler or handlers "
"service this logger, unless a handler's level has been set to a higher "
"severity level than *level*."
msgstr ""
"Establece el umbral para este registrador en ``level``. Los mensajes de "
"registro que son menos severos que ``level`` serán ignorados; los mensajes "
"de registro que tengan un nivel de severidad ``level`` o superior serán "
"emitidos por cualquier manejador o manejadores que atiendan este "
"registrador, a menos que el nivel de un manejador haya sido configurado en "
"un nivel de severidad más alto que el ``level``."

#: ../Doc/library/logging.rst:101
msgid ""
"When a logger is created, the level is set to :const:`NOTSET` (which causes "
"all messages to be processed when the logger is the root logger, or "
"delegation to the parent when the logger is a non-root logger). Note that "
"the root logger is created with level :const:`WARNING`."
msgstr ""
"Cuando se crea un registrador, el nivel se establece en :const:`NOTSET` (que "
"hace que todos los mensajes se procesen cuando el registrador es el "
"registrador raíz, o la delegación al padre cuando el registrador es un "
"registrador no raíz). Tenga en cuenta que el registrador raíz se crea con el "
"nivel :const:`WARNING`."

#: ../Doc/library/logging.rst:106
msgid ""
"The term 'delegation to the parent' means that if a logger has a level of "
"NOTSET, its chain of ancestor loggers is traversed until either an ancestor "
"with a level other than NOTSET is found, or the root is reached."
msgstr ""
"El término ``delegation to the parent`` significa que si un registrador "
"tiene un nivel de NOTSET, su cadena de registradores ancestrales se "
"atraviesa hasta que se encuentra un ancestro con un nivel diferente a NOTSET "
"o se alcanza la raíz."

#: ../Doc/library/logging.rst:110
msgid ""
"If an ancestor is found with a level other than NOTSET, then that ancestor's "
"level is treated as the effective level of the logger where the ancestor "
"search began, and is used to determine how a logging event is handled."
msgstr ""
"Si se encuentra un antepasado con un nivel distinto de NOTSET, entonces el "
"nivel de ese antepasado se trata como el nivel efectivo del registrador "
"donde comenzó la búsqueda de antepasados, y se utiliza para determinar cómo "
"se maneja un evento de registro."

#: ../Doc/library/logging.rst:114
msgid ""
"If the root is reached, and it has a level of NOTSET, then all messages will "
"be processed. Otherwise, the root's level will be used as the effective "
"level."
msgstr ""
"Si se alcanza la raíz y tiene un nivel de NOTSET, se procesarán todos los "
"mensajes. De lo contrario, el nivel de la raíz se utilizará como el nivel "
"efectivo."

#: ../Doc/library/logging.rst:117 ../Doc/library/logging.rst:426
msgid "See :ref:`levels` for a list of levels."
msgstr "Ver :ref:`levels` para obtener una lista de niveles."

#: ../Doc/library/logging.rst:119
msgid ""
"The *level* parameter now accepts a string representation of the level such "
"as 'INFO' as an alternative to the integer constants such as :const:`INFO`. "
"Note, however, that levels are internally stored as integers, and methods "
"such as e.g. :meth:`getEffectiveLevel` and :meth:`isEnabledFor` will return/"
"expect to be passed integers."
msgstr ""
"El parámetro ``level`` ahora acepta una representación de cadena del nivel "
"como ``INFO`` como alternativa a las constantes de enteros como :const:"
"`INFO`. Sin embargo, tenga en cuenta que los niveles se almacenan "
"internamente como e.j. :meth:`getEffectiveLevel` y :meth:`isEnabledFor` "
"devolverá/esperará que se pasen enteros."

#: ../Doc/library/logging.rst:129
msgid ""
"Indicates if a message of severity *level* would be processed by this "
"logger. This method checks first the module-level level set by ``logging."
"disable(level)`` and then the logger's effective level as determined by :"
"meth:`getEffectiveLevel`."
msgstr ""
"Indica si este registrador procesará un mensaje de gravedad ``level``. Este "
"método verifica primero el nivel de nivel de módulo establecido por "
"``logging.disable(level)`` y luego el nivel efectivo del registrador según "
"lo determinado por :meth:`getEffectiveLevel`."

#: ../Doc/library/logging.rst:137
msgid ""
"Indicates the effective level for this logger. If a value other than :const:"
"`NOTSET` has been set using :meth:`setLevel`, it is returned. Otherwise, the "
"hierarchy is traversed towards the root until a value other than :const:"
"`NOTSET` is found, and that value is returned. The value returned is an "
"integer, typically one of :const:`logging.DEBUG`, :const:`logging.INFO` etc."
msgstr ""
"Indica el nivel efectivo para este registrador. Si se ha establecido un "
"valor distinto de :const:`NOTSET` utilizando :meth:`setLevel`, se devuelve. "
"De lo contrario, la jerarquía se atraviesa hacia la raíz hasta que se "
"encuentre un valor que no sea :const:`NOTSET` y se devuelva ese valor. El "
"valor devuelto es un entero, típicamente uno de :const:`logging.DEBUG`, :"
"const:`logging.INFO` etc."

#: ../Doc/library/logging.rst:147
msgid ""
"Returns a logger which is a descendant to this logger, as determined by the "
"suffix. Thus, ``logging.getLogger('abc').getChild('def.ghi')`` would return "
"the same logger as would be returned by ``logging.getLogger('abc.def."
"ghi')``. This is a convenience method, useful when the parent logger is "
"named using e.g. ``__name__`` rather than a literal string."
msgstr ""
"Devuelve un registrador que es descendiente de este registrador, según lo "
"determinado por el sufijo. Por lo tanto, ``logging.getLogger('abc')."
"getChild('def.ghi')`` devolvería el mismo registrador que devolvería "
"``logging.getLogger('abc.def.ghi')``. Este es un método convenientemente "
"útil cuando el registrador principal se nombra usando e.j. ``__name__`` en "
"lugar de una cadena literal."

#: ../Doc/library/logging.rst:158
#, python-format
msgid ""
"Logs a message with level :const:`DEBUG` on this logger. The *msg* is the "
"message format string, and the *args* are the arguments which are merged "
"into *msg* using the string formatting operator. (Note that this means that "
"you can use keywords in the format string, together with a single dictionary "
"argument.) No % formatting operation is performed on *msg* when no *args* "
"are supplied."
msgstr ""
"Registra un mensaje con el nivel :const:`DEBUG` en este registrador. El "
"``msg`` es la cadena de formato del mensaje, y los ``args`` son los "
"argumentos que se fusionan en ``msg`` utilizando el operador de formato de "
"cadena. (Tenga en cuenta que esto significa que puede usar palabras clave en "
"la cadena de formato, junto con un solo argumento de diccionario). No se "
"realiza ninguna operación de formateo % en ``msg`` cuando no se suministran "
"``args``."

#: ../Doc/library/logging.rst:164
msgid ""
"There are four keyword arguments in *kwargs* which are inspected: "
"*exc_info*, *stack_info*, *stacklevel* and *extra*."
msgstr ""
"Hay cuatro argumentos de palabras clave ``kwargs`` que se inspeccionan: "
"``exc_info``, ``stack_info``, ``stacklevel`` y ``extra``."

#: ../Doc/library/logging.rst:167
msgid ""
"If *exc_info* does not evaluate as false, it causes exception information to "
"be added to the logging message. If an exception tuple (in the format "
"returned by :func:`sys.exc_info`) or an exception instance is provided, it "
"is used; otherwise, :func:`sys.exc_info` is called to get the exception "
"information."
msgstr ""
"Si ``exc_info`` no se evalúa como falso, hace que se agregue información de "
"excepción al mensaje de registro. Si se proporciona una tupla de excepción "
"(en el formato devuelto por :func:`sys.exc_info`) o se proporciona una "
"instancia de excepción, se utiliza; de lo contrario, se llama a func:`sys."
"exc_info` para obtener la información de excepción."

#: ../Doc/library/logging.rst:172 ../Doc/library/logging.rst:960
msgid ""
"The second optional keyword argument is *stack_info*, which defaults to "
"``False``. If true, stack information is added to the logging message, "
"including the actual logging call. Note that this is not the same stack "
"information as that displayed through specifying *exc_info*: The former is "
"stack frames from the bottom of the stack up to the logging call in the "
"current thread, whereas the latter is information about stack frames which "
"have been unwound, following an exception, while searching for exception "
"handlers."
msgstr ""
"El segundo argumento opcional con la palabra clave ``stack_info``, que por "
"defecto es falso. Si es verdadero, la información de la pila agregara el "
"mensaje de registro, incluida la actual llamada del registro. Tenga en "
"cuenta que esta no es la misma información de la pila que se muestra al "
"especificar ``exc_info``: la primera son los cuadros de la pila desde la "
"parte inferior de la pila hasta la llamada de registro en el hilo actual, "
"mientras que la segunda es la información sobre los cuadros de la pila que "
"se han desenrollado, siguiendo una excepción, mientras busca manejadores de "
"excepción."

#: ../Doc/library/logging.rst:181 ../Doc/library/logging.rst:969
msgid ""
"You can specify *stack_info* independently of *exc_info*, e.g. to just show "
"how you got to a certain point in your code, even when no exceptions were "
"raised. The stack frames are printed following a header line which says:"
msgstr ""
"Puede especificar ``stack_info`` independientemente de ``exc_info``, e.j. "
"solo para mostrar cómo llegaste a cierto punto en tu código, incluso cuando "
"no se generaron excepciones. Los marcos de la pila se imprimen siguiendo una "
"línea de encabezado que dice:"

#: ../Doc/library/logging.rst:189 ../Doc/library/logging.rst:977
msgid ""
"This mimics the ``Traceback (most recent call last):`` which is used when "
"displaying exception frames."
msgstr ""
"Esto imita el ``Traceback (most recent call last):`` que se usa cuando se "
"muestran marcos de excepción."

#: ../Doc/library/logging.rst:192
msgid ""
"The third optional keyword argument is *stacklevel*, which defaults to "
"``1``. If greater than 1, the corresponding number of stack frames are "
"skipped when computing the line number and function name set in the :class:"
"`LogRecord` created for the logging event. This can be used in logging "
"helpers so that the function name, filename and line number recorded are not "
"the information for the helper function/method, but rather its caller. The "
"name of this parameter mirrors the equivalent one in the :mod:`warnings` "
"module."
msgstr ""
"El tercer argumento opcional con la palabra clave ``stacklevel``, que por "
"defecto es ``1``. Si es mayor que 1, se omite el número correspondiente de "
"cuadros de pila al calcular el número de línea y el nombre de la función "
"establecidos en :class:`LogRecord` creado para el evento de registro. Esto "
"se puede utilizar en el registro de ayudantes para que el nombre de la "
"función, el nombre de archivo y el número de línea registrados no sean la "
"información para la función / método auxiliar, sino más bien su llamador. El "
"nombre de este parámetro refleja el equivalente en el modulo :mod:`warnings`"

#: ../Doc/library/logging.rst:200
msgid ""
"The fourth keyword argument is *extra* which can be used to pass a "
"dictionary which is used to populate the __dict__ of the :class:`LogRecord` "
"created for the logging event with user-defined attributes. These custom "
"attributes can then be used as you like. For example, they could be "
"incorporated into logged messages. For example::"
msgstr ""
"El cuarto argumento de palabra clave es ``extra``, que se puede usar para "
"pasar un diccionario que se usa para completar el __dict__ de :class:"
"`LogRecord` creado para el evento de registro con atributos definidos por el "
"usuario. Estos atributos personalizados se pueden usar a su gusto. Podrían "
"incorporarse en mensajes registrados. Por ejemplo::"

#: ../Doc/library/logging.rst:212
msgid "would print something like"
msgstr "imprimiría algo como"

#: ../Doc/library/logging.rst:218 ../Doc/library/logging.rst:997
msgid ""
"The keys in the dictionary passed in *extra* should not clash with the keys "
"used by the logging system. (See the :class:`Formatter` documentation for "
"more information on which keys are used by the logging system.)"
msgstr ""
"Las claves en el diccionario pasado ``extra`` no deben entrar en conflicto "
"con las claves utilizadas por el sistema de registro. (Ver la documentación "
"de :class:`Formatter` para obtener más información sobre qué claves utiliza "
"el sistema de registro)."

#: ../Doc/library/logging.rst:222
msgid ""
"If you choose to use these attributes in logged messages, you need to "
"exercise some care. In the above example, for instance, the :class:"
"`Formatter` has been set up with a format string which expects 'clientip' "
"and 'user' in the attribute dictionary of the :class:`LogRecord`. If these "
"are missing, the message will not be logged because a string formatting "
"exception will occur. So in this case, you always need to pass the *extra* "
"dictionary with these keys."
msgstr ""
"Si elige usar estos atributos en los mensajes registrados, debe tener "
"cuidado. En el ejemplo anterior, se ha configurado :class:`Formatter` con "
"una cadena de formato que espera *clientip* y 'usuario' en el diccionario de "
"atributos de :class:`LogRecord`. Si faltan, el mensaje no se registrará "
"porque se producirá una excepción de formato de cadena. En este caso, "
"siempre debe pasar el diccionario ``extra`` con estas teclas."

#: ../Doc/library/logging.rst:229 ../Doc/library/logging.rst:1008
msgid ""
"While this might be annoying, this feature is intended for use in "
"specialized circumstances, such as multi-threaded servers where the same "
"code executes in many contexts, and interesting conditions which arise are "
"dependent on this context (such as remote client IP address and "
"authenticated user name, in the above example). In such circumstances, it is "
"likely that specialized :class:`Formatter`\\ s would be used with "
"particular :class:`Handler`\\ s."
msgstr ""
"Si bien esto puede ser molesto, esta función está diseñada para su uso en "
"circunstancias especializadas, como servidores de subprocesos múltiples "
"donde el mismo código se ejecuta en muchos contextos, y las condiciones "
"interesantes que surgen dependen de este contexto (como la dirección IP del "
"cliente remoto y autenticado nombre de usuario, en el ejemplo anterior). En "
"tales circunstancias, es probable que se especialice :class:`Formatter`\\ s "
"con particular :class:`Handler`\\ s."

#: ../Doc/library/logging.rst:236 ../Doc/library/logging.rst:1015
msgid "The *stack_info* parameter was added."
msgstr "Se agregó el parámetro ``stack_info``."

#: ../Doc/library/logging.rst:239
msgid "The *exc_info* parameter can now accept exception instances."
msgstr "El parámetro ``exc_info`` ahora puede aceptar instancias de excepción."

#: ../Doc/library/logging.rst:242
msgid "The *stacklevel* parameter was added."
msgstr "Se agregó el parámetro ``stacklevel``."

#: ../Doc/library/logging.rst:248
msgid ""
"Logs a message with level :const:`INFO` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr ""
"Registra un mensaje con el nivel :const:`INFO` en este registrador. Los "
"argumentos se interpretan como :meth:`debug`."

#: ../Doc/library/logging.rst:254
msgid ""
"Logs a message with level :const:`WARNING` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr ""
"Registra un mensaje con el nivel :const:`WARNING` en este registrador. Los "
"argumentos se interpretan como :meth:`debug`."

#: ../Doc/library/logging.rst:257
msgid ""
"There is an obsolete method ``warn`` which is functionally identical to "
"``warning``. As ``warn`` is deprecated, please do not use it - use "
"``warning`` instead."
msgstr ""
"Hay un método obsoleto ``warn`` que es funcionalmente idéntico a "
"``warning``. Como ``warn`` está en desuso, no lo use, use ``warning`` en su "
"lugar."

#: ../Doc/library/logging.rst:263
msgid ""
"Logs a message with level :const:`ERROR` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr ""
"Registra un mensaje con nivel :const:`ERROR` en este registrador. Los "
"argumentos se interpretan como :meth:`debug`."

#: ../Doc/library/logging.rst:269
msgid ""
"Logs a message with level :const:`CRITICAL` on this logger. The arguments "
"are interpreted as for :meth:`debug`."
msgstr ""
"Registra un mensaje con el nivel :const:`CRITICAL` en este registrador. Los "
"argumentos se interpretan como :meth:`debug`."

#: ../Doc/library/logging.rst:275
msgid ""
"Logs a message with integer level *level* on this logger. The other "
"arguments are interpreted as for :meth:`debug`."
msgstr ""
"Registra un mensaje con nivel entero ``nivel`` en este registrador. Los "
"otros argumentos se interpretan como :meth:`debug`."

#: ../Doc/library/logging.rst:281
msgid ""
"Logs a message with level :const:`ERROR` on this logger. The arguments are "
"interpreted as for :meth:`debug`. Exception info is added to the logging "
"message. This method should only be called from an exception handler."
msgstr ""
"Registra un mensaje con nivel :const:`ERROR` en este registrador. Los "
"argumentos se interpretan como :meth:`debug`. La información de excepción se "
"agrega al mensaje de registro. Este método solo debe llamarse desde un "
"controlador de excepciones."

#: ../Doc/library/logging.rst:288
msgid "Adds the specified filter *filter* to this logger."
msgstr "Agrega el filtro ``filtro`` especificado a este registrador."

#: ../Doc/library/logging.rst:293
msgid "Removes the specified filter *filter* from this logger."
msgstr "Elimina el filtro ``filtro`` especificado de este registrador."

#: ../Doc/library/logging.rst:298
msgid ""
"Apply this logger's filters to the record and return ``True`` if the record "
"is to be processed. The filters are consulted in turn, until one of them "
"returns a false value. If none of them return a false value, the record will "
"be processed (passed to handlers). If one returns a false value, no further "
"processing of the record occurs."
msgstr ""
"Aplique los filtros de este registrador al registro y retorna verdadero si "
"se va a procesar el registro. Los filtros se consultan a su vez, hasta que "
"uno de ellos devuelve un valor falso. Si ninguno de ellos devuelve un valor "
"falso, el registro será procesado (pasado a los manejadores). Si se devuelve "
"un valor falso, no se produce más procesamiento del registro."

#: ../Doc/library/logging.rst:307
msgid "Adds the specified handler *hdlr* to this logger."
msgstr "Agrega el controlador especificado ``hdlr`` a este registrador."

#: ../Doc/library/logging.rst:312
msgid "Removes the specified handler *hdlr* from this logger."
msgstr "Elimina el controlador especificado ``hdlr`` de este registrador."

#: ../Doc/library/logging.rst:317
msgid ""
"Finds the caller's source filename and line number. Returns the filename, "
"line number, function name and stack information as a 4-element tuple. The "
"stack information is returned as ``None`` unless *stack_info* is ``True``."
msgstr ""
"Encuentra el nombre de archivo de origen de la invoca y el número de línea. "
"Devuelve el nombre del archivo, el número de línea, el nombre de la función "
"y la información de la pila como una tupla de 4 elementos. La información de "
"la pila se devuelve como ``None`` a menos que ``stack_info`` sea `verdadero."

#: ../Doc/library/logging.rst:321
msgid ""
"The *stacklevel* parameter is passed from code calling the :meth:`debug` and "
"other APIs. If greater than 1, the excess is used to skip stack frames "
"before determining the values to be returned. This will generally be useful "
"when calling logging APIs from helper/wrapper code, so that the information "
"in the event log refers not to the helper/wrapper code, but to the code that "
"calls it."
msgstr ""
"El parámetro ``stacklevel`` se pasa del código que llama a :meth:`debug` y "
"otras API. Si es mayor que 1, el exceso se utiliza para omitir los cuadros "
"de la pila antes de determinar los valores que se devolverán. Esto "
"generalmente será útil al llamar a las API de registro desde un *helper/"
"wrapper*, de modo que la información en el registro de eventos no se refiera "
"al *helper/wrapper*, sino al código que lo llama."

#: ../Doc/library/logging.rst:331
msgid ""
"Handles a record by passing it to all handlers associated with this logger "
"and its ancestors (until a false value of *propagate* is found). This method "
"is used for unpickled records received from a socket, as well as those "
"created locally. Logger-level filtering is applied using :meth:`~Logger."
"filter`."
msgstr ""
"Maneja un registro pasándolo a todos los controladores asociados con este "
"registrador y sus antepasados (hasta que se encuentre un valor falso de "
"``propagate``). Este método se utiliza para registros no empaquetados "
"recibidos de un socket, así como para aquellos creados localmente. El "
"filtrado a nivel de registrador se aplica usando :meth:`~Logger.filter`."

#: ../Doc/library/logging.rst:339
msgid ""
"This is a factory method which can be overridden in subclasses to create "
"specialized :class:`LogRecord` instances."
msgstr ""
"Este es un método *factory* que se puede *overridden* en subclases para "
"crear instancias especializadas :class:`LogRecord`."

#: ../Doc/library/logging.rst:344
msgid ""
"Checks to see if this logger has any handlers configured. This is done by "
"looking for handlers in this logger and its parents in the logger hierarchy. "
"Returns ``True`` if a handler was found, else ``False``. The method stops "
"searching up the hierarchy whenever a logger with the 'propagate' attribute "
"set to false is found - that will be the last logger which is checked for "
"the existence of handlers."
msgstr ""
"Comprueba si este registrador tiene algún controlador configurado. Esto se "
"hace buscando controladores en este registrador y sus padres en la jerarquía "
"del registrador. Devuelve verdadero si se encontró un controlador, de lo "
"contrario, falso. El método deja de buscar en la jerarquía cada vez que se "
"encuentra un registrador con el atributo *propagate* establecido en falso: "
"ese será el último registrador que verificará la existencia de controladores."

#: ../Doc/library/logging.rst:353
msgid "Loggers can now be pickled and unpickled."
msgstr "Los registradores ahora se pueden ser *pickled and unpickled*."

#: ../Doc/library/logging.rst:359
msgid "Logging Levels"
msgstr "Niveles de registro"

#: ../Doc/library/logging.rst:361
msgid ""
"The numeric values of logging levels are given in the following table. These "
"are primarily of interest if you want to define your own levels, and need "
"them to have specific values relative to the predefined levels. If you "
"define a level with the same numeric value, it overwrites the predefined "
"value; the predefined name is lost."
msgstr ""
"Los valores numéricos de los niveles de registro se dan en la siguiente "
"tabla. Estos son principalmente de interés si desea definir sus propios "
"niveles y necesita que tengan valores específicos en relación con los "
"niveles predefinidos. Si define un nivel con el mismo valor numérico, "
"sobrescribe el valor predefinido; Se pierde el nombre predefinido."

#: ../Doc/library/logging.rst:368
msgid "Level"
msgstr "Nivel"

#: ../Doc/library/logging.rst:368
msgid "Numeric value"
msgstr "Valor numérico"

#: ../Doc/library/logging.rst:370
msgid "``CRITICAL``"
msgstr "``CRITICAL``"

#: ../Doc/library/logging.rst:370
msgid "50"
msgstr "50"

#: ../Doc/library/logging.rst:372
msgid "``ERROR``"
msgstr "``ERROR``"

#: ../Doc/library/logging.rst:372
msgid "40"
msgstr "40"

#: ../Doc/library/logging.rst:374
msgid "``WARNING``"
msgstr "``WARNING``"

#: ../Doc/library/logging.rst:374
msgid "30"
msgstr "30"

#: ../Doc/library/logging.rst:376
msgid "``INFO``"
msgstr "``INFO``"

#: ../Doc/library/logging.rst:376
msgid "20"
msgstr "20"

#: ../Doc/library/logging.rst:378
msgid "``DEBUG``"
msgstr "``DEBUG``"

#: ../Doc/library/logging.rst:378
msgid "10"
msgstr "10"

#: ../Doc/library/logging.rst:380
msgid "``NOTSET``"
msgstr "``NOTSET``"

#: ../Doc/library/logging.rst:380
msgid "0"
msgstr "0"

#: ../Doc/library/logging.rst:387
msgid "Handler Objects"
msgstr "Manejador de objetos"

#: ../Doc/library/logging.rst:389
msgid ""
"Handlers have the following attributes and methods. Note that :class:"
"`Handler` is never instantiated directly; this class acts as a base for more "
"useful subclasses. However, the :meth:`__init__` method in subclasses needs "
"to call :meth:`Handler.__init__`."
msgstr ""
"Los manejadores tienen los siguientes atributos y métodos. Tenga en cuenta "
"que :class:`Handler` nunca se instancia directamente; Esta clase actúa como "
"base para subclases más útiles. Sin embargo, el método :meth:`__init__` en "
"las subclases debe llamar a :meth:`Handler.__init__`."

#: ../Doc/library/logging.rst:398
msgid ""
"Initializes the :class:`Handler` instance by setting its level, setting the "
"list of filters to the empty list and creating a lock (using :meth:"
"`createLock`) for serializing access to an I/O mechanism."
msgstr ""
"Inicializa la instancia :class:`Handler` estableciendo su nivel, "
"configurando la lista de filtros en la lista vacía y creando un bloqueo "
"(usando :meth:`createLock`) para serializar el acceso a un mecanismo de E/S."

#: ../Doc/library/logging.rst:405
msgid ""
"Initializes a thread lock which can be used to serialize access to "
"underlying I/O functionality which may not be threadsafe."
msgstr ""
"Inicializa un bloqueo de subprocesos que se puede utilizar para serializar "
"el acceso a la funcionalidad de E/S subyacente que puede no ser segura para "
"subprocesos."

#: ../Doc/library/logging.rst:411
msgid "Acquires the thread lock created with :meth:`createLock`."
msgstr "Adquiere el bloqueo de hilo creado con :meth:`createLock`."

#: ../Doc/library/logging.rst:416
msgid "Releases the thread lock acquired with :meth:`acquire`."
msgstr "Libera el bloqueo de hilo adquirido con :meth:`acquire`."

#: ../Doc/library/logging.rst:421
msgid ""
"Sets the threshold for this handler to *level*. Logging messages which are "
"less severe than *level* will be ignored. When a handler is created, the "
"level is set to :const:`NOTSET` (which causes all messages to be processed)."
msgstr ""
"Establece el umbral para este controlador en ``level``. Los mensajes de "
"registro que son menos severos que ``level`` serán ignorados. Cuando se crea "
"un controlador, el nivel se establece en :const:`NOTSET` (lo que hace que se "
"procesen todos los mensajes)."

#: ../Doc/library/logging.rst:428
msgid ""
"The *level* parameter now accepts a string representation of the level such "
"as 'INFO' as an alternative to the integer constants such as :const:`INFO`."
msgstr ""
"El parámetro ``level`` ahora acepta una representación de cadena del nivel "
"como 'INFO' como alternativa a las constantes de enteros como :const:`INFO`."

#: ../Doc/library/logging.rst:436
msgid "Sets the :class:`Formatter` for this handler to *fmt*."
msgstr "Establece :class:`Formatter` para este controlador en ``fmt``."

#: ../Doc/library/logging.rst:441
msgid "Adds the specified filter *filter* to this handler."
msgstr "Agrega el filtro ``filtro`` especificado a este controlador."

#: ../Doc/library/logging.rst:446
msgid "Removes the specified filter *filter* from this handler."
msgstr "Elimina el filtro ``filtro`` especificado de este controlador."

#: ../Doc/library/logging.rst:451
msgid ""
"Apply this handler's filters to the record and return ``True`` if the record "
"is to be processed. The filters are consulted in turn, until one of them "
"returns a false value. If none of them return a false value, the record will "
"be emitted. If one returns a false value, the handler will not emit the "
"record."
msgstr ""
"Aplique los filtros de este controlador al registro y devuelve verdadero si "
"se va a procesar el registro. Los filtros se consultan a su vez, hasta que "
"uno de ellos devuelve un valor falso. Si ninguno de ellos devuelve un valor "
"falso, se emitirá el registro. Si uno devuelve un valor falso, el "
"controlador no emitirá el registro."

#: ../Doc/library/logging.rst:460
msgid ""
"Ensure all logging output has been flushed. This version does nothing and is "
"intended to be implemented by subclasses."
msgstr ""
"Asegúrese de que toda la salida de registro se haya vaciado. Esta versión no "
"hace nada y está destinada a ser implementada por subclases."

#: ../Doc/library/logging.rst:466
msgid ""
"Tidy up any resources used by the handler. This version does no output but "
"removes the handler from an internal list of handlers which is closed when :"
"func:`shutdown` is called. Subclasses should ensure that this gets called "
"from overridden :meth:`close` methods."
msgstr ""
"Poner en orden los recursos utilizados por el controlador. Esta versión no "
"genera salida, pero elimina el controlador de una lista interna de "
"controladores que se cierra cuando se llama a :func:`shutdown`. Las "
"subclases deben garantizar que esto se llame desde métodos *overridden* :"
"meth:`close`."

#: ../Doc/library/logging.rst:474
msgid ""
"Conditionally emits the specified logging record, depending on filters which "
"may have been added to the handler. Wraps the actual emission of the record "
"with acquisition/release of the I/O thread lock."
msgstr ""
"Emite condicionalmente el registro especifico, según los filtros que se "
"hayan agregado al controlador. Envuelve la actual emisión del registro con "
"*acquisition/release* del hilo de bloqueo E/S."

#: ../Doc/library/logging.rst:481
msgid ""
"This method should be called from handlers when an exception is encountered "
"during an :meth:`emit` call. If the module-level attribute "
"``raiseExceptions`` is ``False``, exceptions get silently ignored. This is "
"what is mostly wanted for a logging system - most users will not care about "
"errors in the logging system, they are more interested in application "
"errors. You could, however, replace this with a custom handler if you wish. "
"The specified record is the one which was being processed when the exception "
"occurred. (The default value of ``raiseExceptions`` is ``True``, as that is "
"more useful during development)."
msgstr ""
"Este método debe llamarse desde los gestores cuando se encuentra una "
"excepción durante una llamada a :meth:`emit`. Si el atributo de nivel de "
"módulo ``raiseExceptions`` es `` False``, las excepciones se ignoran "
"silenciosamente. Esto es lo que más se necesita para un sistema de registro: "
"a la mayoría de los usuarios no les importan los errores en el sistema de "
"registro, están más interesados en los errores de la aplicación. Sin "
"embargo, puede reemplazar esto con un gestor personalizado si lo desea. El "
"registro especificado es el que se estaba procesando cuando se produjo la "
"excepción. (El valor predeterminado de ``raiseExceptions`` es `` True``, ya "
"que es más útil durante el desarrollo)."

#: ../Doc/library/logging.rst:494
msgid ""
"Do formatting for a record - if a formatter is set, use it. Otherwise, use "
"the default formatter for the module."
msgstr ""
"Formato para un registro - si se configura un formateador, úselo. De lo "
"contrario, use el formateador predeterminado para el módulo."

#: ../Doc/library/logging.rst:500
msgid ""
"Do whatever it takes to actually log the specified logging record. This "
"version is intended to be implemented by subclasses and so raises a :exc:"
"`NotImplementedError`."
msgstr ""
"Haga lo que sea necesario para registrar de forma especifica el registro. "
"Esta versión está destinada a ser implementada por subclases y, por lo "
"tanto, genera un :exc:`NotImplementedError`."

#: ../Doc/library/logging.rst:504
msgid ""
"For a list of handlers included as standard, see :mod:`logging.handlers`."
msgstr ""
"Para obtener una lista de gestores incluidos como estándar, consulte :mod:"
"`logging.handlers`."

#: ../Doc/library/logging.rst:509
msgid "Formatter Objects"
msgstr "Objetos formateadores"

#: ../Doc/library/logging.rst:513
#, python-format
msgid ""
":class:`Formatter` objects have the following attributes and methods. They "
"are responsible for converting a :class:`LogRecord` to (usually) a string "
"which can be interpreted by either a human or an external system. The base :"
"class:`Formatter` allows a formatting string to be specified. If none is "
"supplied, the default value of ``'%(message)s'`` is used, which just "
"includes the message in the logging call. To have additional items of "
"information in the formatted output (such as a timestamp), keep reading."
msgstr ""
":class:`Formatter` tiene los siguientes atributos y métodos. Son "
"responsables de convertir una :class:`LogRecord` a (generalmente) una cadena "
"que puede ser interpretada por un sistema humano o externo. La base :class:"
"`Formatter` permite especificar una cadena de formato. Si no se proporciona "
"ninguno, se utiliza el valor predeterminado de ``'%(message)s'``, que solo "
"incluye el mensaje en la llamada de registro. Para tener elementos de "
"información adicionales en la salida formateada (como una marca de tiempo), "
"siga leyendo."

#: ../Doc/library/logging.rst:521
#, python-format
msgid ""
"A Formatter can be initialized with a format string which makes use of "
"knowledge of the :class:`LogRecord` attributes - such as the default value "
"mentioned above making use of the fact that the user's message and arguments "
"are pre-formatted into a :class:`LogRecord`'s *message* attribute.  This "
"format string contains standard Python %-style mapping keys. See section :"
"ref:`old-string-formatting` for more information on string formatting."
msgstr ""
"Un formateador se puede inicializar con una cadena de formato que utiliza el "
"conocimiento de los atributos :class:`LogRecord`, como el valor "
"predeterminado mencionado anteriormente, haciendo uso del hecho de que el "
"mensaje y los argumentos del usuario están formateados previamente en :class:"
"`LogRecord`'s con *message* como atributo. Esta cadena de formato contiene "
"claves de mapeo de Python %-style estándar. Ver la sección :ref:`old-string-"
"formatting` para obtener más información sobre el formato de cadenas."

#: ../Doc/library/logging.rst:528
msgid ""
"The useful mapping keys in a :class:`LogRecord` are given in the section on :"
"ref:`logrecord-attributes`."
msgstr ""
"Las claves de mapeo útiles en a :class:`LogRecord` se dan en la sección "
"sobre :ref:`logrecord-attributes`."

#: ../Doc/library/logging.rst:534
#, python-format
msgid ""
"Returns a new instance of the :class:`Formatter` class.  The instance is "
"initialized with a format string for the message as a whole, as well as a "
"format string for the date/time portion of a message.  If no *fmt* is "
"specified, ``'%(message)s'`` is used.  If no *datefmt* is specified, a "
"format is used which is described in the :meth:`formatTime` documentation."
msgstr ""
"Devuelve una nueva instancia de :class:`Formatter`. La instancia se "
"inicializa con una cadena de formato para el mensaje en su conjunto, así "
"como una cadena de formato para la porción fecha/hora de un mensaje. Si no "
"se especifica *fmt*, se utiliza ``'%(message)s'``. Si no se especifica "
"*datefmt*, se utiliza un formato que se describe en la documentación :meth:"
"`formatTime`."

#: ../Doc/library/logging.rst:540
#, python-format
msgid ""
"The *style* parameter can be one of '%', '{' or '$' and determines how the "
"format string will be merged with its data: using one of %-formatting, :meth:"
"`str.format` or :class:`string.Template`. See :ref:`formatting-styles` for "
"more information on using {- and $-formatting for log messages."
msgstr ""
"El parámetro *style* puede ser uno de '%', '{'' o '$' y determina cómo se "
"fusionará la cadena de formato con sus datos: usando uno de %-formatting, :"
"meth:`str.format` o :class:`string.Template`. Ver :ref:`formatting-styles` "
"para obtener más información sobre el uso de {- y $ -para formateo de los "
"mensajes de registro."

#: ../Doc/library/logging.rst:545
msgid "The *style* parameter was added."
msgstr "Se agregó el parámetro *style*."

#: ../Doc/library/logging.rst:548
#, python-format
msgid ""
"The *validate* parameter was added. Incorrect or mismatched style and fmt "
"will raise a ``ValueError``. For example: ``logging.Formatter('%(asctime)s - "
"%(message)s', style='{')``."
msgstr ""
"Se agregó el parámetro *validate*. Si el estilo es incorrecto o no "
"coincidente, fmt generará un ``ValueError``. Por ejemplo: ``logging."
"Formatter('%(asctime)s - %(message)s', style='{')``."

#: ../Doc/library/logging.rst:555
msgid ""
"The record's attribute dictionary is used as the operand to a string "
"formatting operation. Returns the resulting string. Before formatting the "
"dictionary, a couple of preparatory steps are carried out. The *message* "
"attribute of the record is computed using *msg* % *args*. If the formatting "
"string contains ``'(asctime)'``, :meth:`formatTime` is called to format the "
"event time. If there is exception information, it is formatted using :meth:"
"`formatException` and appended to the message. Note that the formatted "
"exception information is cached in attribute *exc_text*. This is useful "
"because the exception information can be pickled and sent across the wire, "
"but you should be careful if you have more than one :class:`Formatter` "
"subclass which customizes the formatting of exception information. In this "
"case, you will have to clear the cached value after a formatter has done its "
"formatting, so that the next formatter to handle the event doesn't use the "
"cached value but recalculates it afresh."
msgstr ""
"El diccionario de atributos del registro se usa como el operando de una "
"operación para formateo de cadenas. Devuelve la cadena resultante. Antes de "
"formatear el diccionario, se llevan a cabo un par de pasos preparatorios. El "
"atributo *message* del registro se calcula usando *msg* % *args*. Si el "
"formato de la cadena contiene ``'(asctime)'``, :meth:`formatTime` es llamado "
"para dar formato al evento. Si hay información sobre la excepción, se "
"formatea usando :meth:`formatException` y se adjunta al mensaje. Tenga en "
"cuenta que la información de excepción formateada se almacena en caché en el "
"atributo *exc_text*. Esto es útil porque la información de excepción se "
"puede *pickled* y propagarse en el cable, pero debe tener cuidado si tiene "
"más de una subclase :class:`Formatter` que personaliza el formato de la "
"información de la excepción. En este caso, tendrá que borrar el valor "
"almacenado en caché después de que un formateador haya terminado su "
"formateo, para que el siguiente formateador que maneje el evento no use el "
"valor almacenado en caché sino que lo recalcule."

#: ../Doc/library/logging.rst:571
msgid ""
"If stack information is available, it's appended after the exception "
"information, using :meth:`formatStack` to transform it if necessary."
msgstr ""
"Si la información de la pila está disponible, se agrega después de la "
"información de la excepción, usando :meth:`formatStack` para transformarla "
"si es necesario."

#: ../Doc/library/logging.rst:577
#, python-format
msgid ""
"This method should be called from :meth:`format` by a formatter which wants "
"to make use of a formatted time. This method can be overridden in formatters "
"to provide for any specific requirement, but the basic behavior is as "
"follows: if *datefmt* (a string) is specified, it is used with :func:`time."
"strftime` to format the creation time of the record. Otherwise, the format "
"'%Y-%m-%d %H:%M:%S,uuu' is used, where the uuu part is a millisecond value "
"and the other letters are as per the :func:`time.strftime` documentation.  "
"An example time in this format is ``2003-01-23 00:29:50,411``.  The "
"resulting string is returned."
msgstr ""
"Este método debe ser llamado desde :meth:`format` por un formateador que "
"espera un tiempo formateado . Este método se puede reemplazar en "
"formateadores para proporcionar cualquier requisito específico, pero el "
"comportamiento básico es el siguiente: if *datefmt* (una cadena), se usa "
"con :func:`time.strftime` para formatear el tiempo de creación del registro "
"De lo contrario, se utiliza el formato '%Y-%m-%d %H:%M:%S,uuu', donde la "
"parte uuu es un valor de milisegundos y las otras letras son :func:`time."
"strftime` . Un ejemplo de tiempo en este formato es ``2003-01-23 "
"00:29:50,411``. Se devuelve la cadena resultante."

#: ../Doc/library/logging.rst:587
msgid ""
"This function uses a user-configurable function to convert the creation time "
"to a tuple. By default, :func:`time.localtime` is used; to change this for a "
"particular formatter instance, set the ``converter`` attribute to a function "
"with the same signature as :func:`time.localtime` or :func:`time.gmtime`. To "
"change it for all formatters, for example if you want all logging times to "
"be shown in GMT, set the ``converter`` attribute in the ``Formatter`` class."
msgstr ""
"Esta función utiliza una función configurable por el usuario para convertir "
"el tiempo de creación en una tupla. Por defecto, se utiliza :func:`time."
"localtime`; Para cambiar esto para una instancia de formateador particular, "
"se agrega el atributo ``converter`` en una función con igual firma como :"
"func:`time.localtime` o :func:`time.gmtime`. Para cambiarlo en todos los "
"formateadores, por ejemplo, si desea que todos los tiempos de registro se "
"muestren en GMT, agregue el atributo ``converter`` en la clase ``Formatter``."

#: ../Doc/library/logging.rst:595
#, python-format
msgid ""
"Previously, the default format was hard-coded as in this example: "
"``2010-09-06 22:38:15,292`` where the part before the comma is handled by a "
"strptime format string (``'%Y-%m-%d %H:%M:%S'``), and the part after the "
"comma is a millisecond value. Because strptime does not have a format "
"placeholder for milliseconds, the millisecond value is appended using "
"another format string, ``'%s,%03d'`` --- and both of these format strings "
"have been hardcoded into this method. With the change, these strings are "
"defined as class-level attributes which can be overridden at the instance "
"level when desired. The names of the attributes are ``default_time_format`` "
"(for the strptime format string) and ``default_msec_format`` (for appending "
"the millisecond value)."
msgstr ""
"Anteriormente, el formato predeterminado estaba codificado como en este "
"ejemplo: ``2010-09-06 22:38:15,292`` donde la parte anterior a la coma es "
"manejada por una cadena de formato strptime (``'%Y-%m-%d %H:%M:%S'``), y la "
"parte después de la coma es un valor de milisegundos. Debido a que strptime "
"no tiene una posición de formato para milisegundos, el valor de milisegundos "
"se agrega usando otra cadena de formato, ``'%s,%03d'``--- ambas cadenas de "
"formato se han codificado en este método. Con el cambio, estas cadenas se "
"definen como atributos de nivel de clase que pueden *overridden* a nivel de "
"instancia cuando se desee. Los nombres de los atributos son "
"``default_time_format`` (para una cadena de formato strptime) y "
"``default_msec_format`` (para agregar el valor de milisegundos)."

#: ../Doc/library/logging.rst:610
msgid ""
"Formats the specified exception information (a standard exception tuple as "
"returned by :func:`sys.exc_info`) as a string. This default implementation "
"just uses :func:`traceback.print_exception`. The resulting string is "
"returned."
msgstr ""
"Formatea la información de una excepción especificada (una excepción como "
"una tupla estándar es devuelta por :func:`sys.exc_info`) como una cadena. "
"Esta implementación predeterminada solo usa :func:`traceback."
"print_exception`. La cadena resultantes devuelta."

#: ../Doc/library/logging.rst:617
msgid ""
"Formats the specified stack information (a string as returned by :func:"
"`traceback.print_stack`, but with the last newline removed) as a string. "
"This default implementation just returns the input value."
msgstr ""
"Formatea la información de una pila especificada (una cadena es devuelta "
"por :func:`traceback.print_stack`, pero con la ultima línea removida) como "
"una cadena. Esta implementación predeterminada solo devuelve el valor de "
"entrada."

#: ../Doc/library/logging.rst:624
msgid "Filter Objects"
msgstr "Filtro de Objetos"

#: ../Doc/library/logging.rst:626
msgid ""
"``Filters`` can be used by ``Handlers`` and ``Loggers`` for more "
"sophisticated filtering than is provided by levels. The base filter class "
"only allows events which are below a certain point in the logger hierarchy. "
"For example, a filter initialized with 'A.B' will allow events logged by "
"loggers 'A.B', 'A.B.C', 'A.B.C.D', 'A.B.D' etc. but not 'A.BB', 'B.A.B' etc. "
"If initialized with the empty string, all events are passed."
msgstr ""
"Los ``Manejadores`` y los ``Registradores`` pueden usar los ``Filtros`` para "
"un filtrado más sofisticado que el proporcionado por los niveles. La clase "
"de filtro base solo permite eventos que están por debajo de cierto punto en "
"la jerarquía del registrador. Por ejemplo, un filtro inicializado con 'A.B' "
"permitirá los eventos registrados por los registradores 'A.B', 'A.B.C', 'A.B."
"C.D', 'A.B.D' etc., pero no 'A.BB', 'B.A.B', etc. Si se inicializa con una "
"cadena vacía, se pasan todos los eventos."

#: ../Doc/library/logging.rst:636
msgid ""
"Returns an instance of the :class:`Filter` class. If *name* is specified, it "
"names a logger which, together with its children, will have its events "
"allowed through the filter. If *name* is the empty string, allows every "
"event."
msgstr ""

#: ../Doc/library/logging.rst:643
msgid ""
"Is the specified record to be logged? Returns zero for no, nonzero for yes. "
"If deemed appropriate, the record may be modified in-place by this method."
msgstr ""

#: ../Doc/library/logging.rst:647
msgid ""
"Note that filters attached to handlers are consulted before an event is "
"emitted by the handler, whereas filters attached to loggers are consulted "
"whenever an event is logged (using :meth:`debug`, :meth:`info`, etc.), "
"before sending an event to handlers. This means that events which have been "
"generated by descendant loggers will not be filtered by a logger's filter "
"setting, unless the filter has also been applied to those descendant loggers."
msgstr ""

#: ../Doc/library/logging.rst:654
msgid ""
"You don't actually need to subclass ``Filter``: you can pass any instance "
"which has a ``filter`` method with the same semantics."
msgstr ""

#: ../Doc/library/logging.rst:657
msgid ""
"You don't need to create specialized ``Filter`` classes, or use other "
"classes with a ``filter`` method: you can use a function (or other callable) "
"as a filter. The filtering logic will check to see if the filter object has "
"a ``filter`` attribute: if it does, it's assumed to be a ``Filter`` and its :"
"meth:`~Filter.filter` method is called. Otherwise, it's assumed to be a "
"callable and called with the record as the single parameter. The returned "
"value should conform to that returned by :meth:`~Filter.filter`."
msgstr ""

#: ../Doc/library/logging.rst:667
msgid ""
"Although filters are used primarily to filter records based on more "
"sophisticated criteria than levels, they get to see every record which is "
"processed by the handler or logger they're attached to: this can be useful "
"if you want to do things like counting how many records were processed by a "
"particular logger or handler, or adding, changing or removing attributes in "
"the :class:`LogRecord` being processed. Obviously changing the LogRecord "
"needs to be done with some care, but it does allow the injection of "
"contextual information into logs (see :ref:`filters-contextual`)."
msgstr ""

#: ../Doc/library/logging.rst:679
msgid "LogRecord Objects"
msgstr ""

#: ../Doc/library/logging.rst:681
msgid ""
":class:`LogRecord` instances are created automatically by the :class:"
"`Logger` every time something is logged, and can be created manually via :"
"func:`makeLogRecord` (for example, from a pickled event received over the "
"wire)."
msgstr ""

#: ../Doc/library/logging.rst:689
msgid "Contains all the information pertinent to the event being logged."
msgstr ""

#: ../Doc/library/logging.rst:691
msgid ""
"The primary information is passed in :attr:`msg` and :attr:`args`, which are "
"combined using ``msg % args`` to create the :attr:`message` field of the "
"record."
msgstr ""

#: ../Doc/library/logging.rst
msgid "Parameters"
msgstr ""

#: ../Doc/library/logging.rst:695
msgid ""
"The name of the logger used to log the event represented by this LogRecord. "
"Note that this name will always have this value, even though it may be "
"emitted by a handler attached to a different (ancestor) logger."
msgstr ""

#: ../Doc/library/logging.rst:699
msgid ""
"The numeric level of the logging event (one of DEBUG, INFO etc.) Note that "
"this is converted to *two* attributes of the LogRecord: ``levelno`` for the "
"numeric value and ``levelname`` for the corresponding level name."
msgstr ""

#: ../Doc/library/logging.rst:703
msgid "The full pathname of the source file where the logging call was made."
msgstr ""

#: ../Doc/library/logging.rst:705
msgid "The line number in the source file where the logging call was made."
msgstr ""

#: ../Doc/library/logging.rst:707
msgid ""
"The event description message, possibly a format string with placeholders "
"for variable data."
msgstr ""

#: ../Doc/library/logging.rst:709
msgid ""
"Variable data to merge into the *msg* argument to obtain the event "
"description."
msgstr ""

#: ../Doc/library/logging.rst:711
msgid ""
"An exception tuple with the current exception information, or ``None`` if no "
"exception information is available."
msgstr ""

#: ../Doc/library/logging.rst:713
msgid ""
"The name of the function or method from which the logging call was invoked."
msgstr ""

#: ../Doc/library/logging.rst:715
msgid ""
"A text string representing stack information from the base of the stack in "
"the current thread, up to the logging call."
msgstr ""

#: ../Doc/library/logging.rst:720
msgid ""
"Returns the message for this :class:`LogRecord` instance after merging any "
"user-supplied arguments with the message. If the user-supplied message "
"argument to the logging call is not a string, :func:`str` is called on it to "
"convert it to a string. This allows use of user-defined classes as messages, "
"whose ``__str__`` method can return the actual format string to be used."
msgstr ""

#: ../Doc/library/logging.rst:727
msgid ""
"The creation of a :class:`LogRecord` has been made more configurable by "
"providing a factory which is used to create the record. The factory can be "
"set using :func:`getLogRecordFactory` and :func:`setLogRecordFactory` (see "
"this for the factory's signature)."
msgstr ""

#: ../Doc/library/logging.rst:733
msgid ""
"This functionality can be used to inject your own values into a :class:"
"`LogRecord` at creation time. You can use the following pattern::"
msgstr ""

#: ../Doc/library/logging.rst:745
msgid ""
"With this pattern, multiple factories could be chained, and as long as they "
"don't overwrite each other's attributes or unintentionally overwrite the "
"standard attributes listed above, there should be no surprises."
msgstr ""

#: ../Doc/library/logging.rst:754
msgid "LogRecord attributes"
msgstr ""

#: ../Doc/library/logging.rst:756
#, python-format
msgid ""
"The LogRecord has a number of attributes, most of which are derived from the "
"parameters to the constructor. (Note that the names do not always correspond "
"exactly between the LogRecord constructor parameters and the LogRecord "
"attributes.) These attributes can be used to merge data from the record into "
"the format string. The following table lists (in alphabetical order) the "
"attribute names, their meanings and the corresponding placeholder in a "
"%-style format string."
msgstr ""

#: ../Doc/library/logging.rst:764
msgid ""
"If you are using {}-formatting (:func:`str.format`), you can use ``{attrname}"
"`` as the placeholder in the format string. If you are using $-formatting (:"
"class:`string.Template`), use the form ``${attrname}``. In both cases, of "
"course, replace ``attrname`` with the actual attribute name you want to use."
msgstr ""

#: ../Doc/library/logging.rst:770
msgid ""
"In the case of {}-formatting, you can specify formatting flags by placing "
"them after the attribute name, separated from it with a colon. For example: "
"a placeholder of ``{msecs:03d}`` would format a millisecond value of ``4`` "
"as ``004``. Refer to the :meth:`str.format` documentation for full details "
"on the options available to you."
msgstr ""

#: ../Doc/library/logging.rst:777
msgid "Attribute name"
msgstr ""

#: ../Doc/library/logging.rst:777 ../Doc/library/logging.rst:1153
msgid "Format"
msgstr ""

#: ../Doc/library/logging.rst:777 ../Doc/library/logging.rst:1153
msgid "Description"
msgstr ""

#: ../Doc/library/logging.rst ../Doc/library/logging.rst:779
msgid "args"
msgstr ""

#: ../Doc/library/logging.rst:779 ../Doc/library/logging.rst:793
#: ../Doc/library/logging.rst:821 ../Doc/library/logging.rst:839
msgid "You shouldn't need to format this yourself."
msgstr ""

#: ../Doc/library/logging.rst:779
msgid ""
"The tuple of arguments merged into ``msg`` to produce ``message``, or a dict "
"whose values are used for the merge (when there is only one argument, and it "
"is a dictionary)."
msgstr ""

#: ../Doc/library/logging.rst:784
msgid "asctime"
msgstr ""

#: ../Doc/library/logging.rst:784
#, python-format
msgid "``%(asctime)s``"
msgstr ""

#: ../Doc/library/logging.rst:784
msgid ""
"Human-readable time when the :class:`LogRecord` was created.  By default "
"this is of the form '2003-07-08 16:49:45,896' (the numbers after the comma "
"are millisecond portion of the time)."
msgstr ""

#: ../Doc/library/logging.rst:790
msgid "created"
msgstr ""

#: ../Doc/library/logging.rst:790
#, python-format
msgid "``%(created)f``"
msgstr ""

#: ../Doc/library/logging.rst:790
msgid ""
"Time when the :class:`LogRecord` was created (as returned by :func:`time."
"time`)."
msgstr ""

#: ../Doc/library/logging.rst ../Doc/library/logging.rst:793
msgid "exc_info"
msgstr ""

#: ../Doc/library/logging.rst:793
msgid ""
"Exception tuple (à la ``sys.exc_info``) or, if no exception has occurred, "
"``None``."
msgstr ""

#: ../Doc/library/logging.rst:796
msgid "filename"
msgstr ""

#: ../Doc/library/logging.rst:796
#, python-format
msgid "``%(filename)s``"
msgstr ""

#: ../Doc/library/logging.rst:796
msgid "Filename portion of ``pathname``."
msgstr ""

#: ../Doc/library/logging.rst:798
msgid "funcName"
msgstr ""

#: ../Doc/library/logging.rst:798
#, python-format
msgid "``%(funcName)s``"
msgstr ""

#: ../Doc/library/logging.rst:798
msgid "Name of function containing the logging call."
msgstr ""

#: ../Doc/library/logging.rst:800
msgid "levelname"
msgstr ""

#: ../Doc/library/logging.rst:800
#, python-format
msgid "``%(levelname)s``"
msgstr ""

#: ../Doc/library/logging.rst:800
msgid ""
"Text logging level for the message (``'DEBUG'``, ``'INFO'``, ``'WARNING'``, "
"``'ERROR'``, ``'CRITICAL'``)."
msgstr ""

#: ../Doc/library/logging.rst:804
msgid "levelno"
msgstr ""

#: ../Doc/library/logging.rst:804
#, python-format
msgid "``%(levelno)s``"
msgstr ""

#: ../Doc/library/logging.rst:804
msgid ""
"Numeric logging level for the message (:const:`DEBUG`, :const:`INFO`, :const:"
"`WARNING`, :const:`ERROR`, :const:`CRITICAL`)."
msgstr ""

#: ../Doc/library/logging.rst:809
msgid "lineno"
msgstr ""

#: ../Doc/library/logging.rst:809
#, python-format
msgid "``%(lineno)d``"
msgstr ""

#: ../Doc/library/logging.rst:809
msgid "Source line number where the logging call was issued (if available)."
msgstr ""

#: ../Doc/library/logging.rst:812
msgid "message"
msgstr ""

#: ../Doc/library/logging.rst:812
#, python-format
msgid "``%(message)s``"
msgstr ""

#: ../Doc/library/logging.rst:812
msgid ""
"The logged message, computed as ``msg % args``. This is set when :meth:"
"`Formatter.format` is invoked."
msgstr ""

#: ../Doc/library/logging.rst:816
msgid "module"
msgstr ""

#: ../Doc/library/logging.rst:816
#, python-format
msgid "``%(module)s``"
msgstr ""

#: ../Doc/library/logging.rst:816
msgid "Module (name portion of ``filename``)."
msgstr ""

#: ../Doc/library/logging.rst:818
msgid "msecs"
msgstr ""

#: ../Doc/library/logging.rst:818
#, python-format
msgid "``%(msecs)d``"
msgstr ""

#: ../Doc/library/logging.rst:818
msgid ""
"Millisecond portion of the time when the :class:`LogRecord` was created."
msgstr ""

#: ../Doc/library/logging.rst ../Doc/library/logging.rst:821
msgid "msg"
msgstr ""

#: ../Doc/library/logging.rst:821
msgid ""
"The format string passed in the original logging call. Merged with ``args`` "
"to produce ``message``, or an arbitrary object (see :ref:`arbitrary-object-"
"messages`)."
msgstr ""

#: ../Doc/library/logging.rst ../Doc/library/logging.rst:826
msgid "name"
msgstr ""

#: ../Doc/library/logging.rst:826
#, python-format
msgid "``%(name)s``"
msgstr ""

#: ../Doc/library/logging.rst:826
msgid "Name of the logger used to log the call."
msgstr ""

#: ../Doc/library/logging.rst:828
msgid "pathname"
msgstr ""

#: ../Doc/library/logging.rst:828
#, python-format
msgid "``%(pathname)s``"
msgstr ""

#: ../Doc/library/logging.rst:828
msgid ""
"Full pathname of the source file where the logging call was issued (if "
"available)."
msgstr ""

#: ../Doc/library/logging.rst:831
msgid "process"
msgstr ""

#: ../Doc/library/logging.rst:831
#, python-format
msgid "``%(process)d``"
msgstr ""

#: ../Doc/library/logging.rst:831
msgid "Process ID (if available)."
msgstr ""

#: ../Doc/library/logging.rst:833
msgid "processName"
msgstr ""

#: ../Doc/library/logging.rst:833
#, python-format
msgid "``%(processName)s``"
msgstr ""

#: ../Doc/library/logging.rst:833
msgid "Process name (if available)."
msgstr ""

#: ../Doc/library/logging.rst:835
msgid "relativeCreated"
msgstr ""

#: ../Doc/library/logging.rst:835
#, python-format
msgid "``%(relativeCreated)d``"
msgstr ""

#: ../Doc/library/logging.rst:835
msgid ""
"Time in milliseconds when the LogRecord was created, relative to the time "
"the logging module was loaded."
msgstr ""

#: ../Doc/library/logging.rst:839
msgid "stack_info"
msgstr ""

#: ../Doc/library/logging.rst:839
msgid ""
"Stack frame information (where available) from the bottom of the stack in "
"the current thread, up to and including the stack frame of the logging call "
"which resulted in the creation of this record."
msgstr ""

#: ../Doc/library/logging.rst:845
msgid "thread"
msgstr ""

#: ../Doc/library/logging.rst:845
#, python-format
msgid "``%(thread)d``"
msgstr ""

#: ../Doc/library/logging.rst:845
msgid "Thread ID (if available)."
msgstr ""

#: ../Doc/library/logging.rst:847
msgid "threadName"
msgstr ""

#: ../Doc/library/logging.rst:847
#, python-format
msgid "``%(threadName)s``"
msgstr ""

#: ../Doc/library/logging.rst:847
msgid "Thread name (if available)."
msgstr ""

#: ../Doc/library/logging.rst:850
msgid "*processName* was added."
msgstr ""

#: ../Doc/library/logging.rst:857
msgid "LoggerAdapter Objects"
msgstr ""

#: ../Doc/library/logging.rst:859
msgid ""
":class:`LoggerAdapter` instances are used to conveniently pass contextual "
"information into logging calls. For a usage example, see the section on :ref:"
"`adding contextual information to your logging output <context-info>`."
msgstr ""

#: ../Doc/library/logging.rst:865
msgid ""
"Returns an instance of :class:`LoggerAdapter` initialized with an "
"underlying :class:`Logger` instance and a dict-like object."
msgstr ""

#: ../Doc/library/logging.rst:870
msgid ""
"Modifies the message and/or keyword arguments passed to a logging call in "
"order to insert contextual information. This implementation takes the object "
"passed as *extra* to the constructor and adds it to *kwargs* using key "
"'extra'. The return value is a (*msg*, *kwargs*) tuple which has the "
"(possibly modified) versions of the arguments passed in."
msgstr ""

#: ../Doc/library/logging.rst:876
msgid ""
"In addition to the above, :class:`LoggerAdapter` supports the following "
"methods of :class:`Logger`: :meth:`~Logger.debug`, :meth:`~Logger.info`, :"
"meth:`~Logger.warning`, :meth:`~Logger.error`, :meth:`~Logger.exception`, :"
"meth:`~Logger.critical`, :meth:`~Logger.log`, :meth:`~Logger.isEnabledFor`, :"
"meth:`~Logger.getEffectiveLevel`, :meth:`~Logger.setLevel` and :meth:"
"`~Logger.hasHandlers`. These methods have the same signatures as their "
"counterparts in :class:`Logger`, so you can use the two types of instances "
"interchangeably."
msgstr ""

#: ../Doc/library/logging.rst:885
msgid ""
"The :meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, :meth:"
"`~Logger.setLevel` and :meth:`~Logger.hasHandlers` methods were added to :"
"class:`LoggerAdapter`.  These methods delegate to the underlying logger."
msgstr ""

#: ../Doc/library/logging.rst:892
msgid "Thread Safety"
msgstr ""

#: ../Doc/library/logging.rst:894
msgid ""
"The logging module is intended to be thread-safe without any special work "
"needing to be done by its clients. It achieves this though using threading "
"locks; there is one lock to serialize access to the module's shared data, "
"and each handler also creates a lock to serialize access to its underlying I/"
"O."
msgstr ""

#: ../Doc/library/logging.rst:899
msgid ""
"If you are implementing asynchronous signal handlers using the :mod:`signal` "
"module, you may not be able to use logging from within such handlers. This "
"is because lock implementations in the :mod:`threading` module are not "
"always re-entrant, and so cannot be invoked from such signal handlers."
msgstr ""

#: ../Doc/library/logging.rst:906
msgid "Module-Level Functions"
msgstr ""

#: ../Doc/library/logging.rst:908
msgid ""
"In addition to the classes described above, there are a number of module-"
"level functions."
msgstr ""

#: ../Doc/library/logging.rst:914
msgid ""
"Return a logger with the specified name or, if name is ``None``, return a "
"logger which is the root logger of the hierarchy. If specified, the name is "
"typically a dot-separated hierarchical name like *'a'*, *'a.b'* or *'a.b.c."
"d'*. Choice of these names is entirely up to the developer who is using "
"logging."
msgstr ""

#: ../Doc/library/logging.rst:919
msgid ""
"All calls to this function with a given name return the same logger "
"instance. This means that logger instances never need to be passed between "
"different parts of an application."
msgstr ""

#: ../Doc/library/logging.rst:926
msgid ""
"Return either the standard :class:`Logger` class, or the last class passed "
"to :func:`setLoggerClass`. This function may be called from within a new "
"class definition, to ensure that installing a customized :class:`Logger` "
"class will not undo customizations already applied by other code. For "
"example::"
msgstr ""

#: ../Doc/library/logging.rst:937
msgid "Return a callable which is used to create a :class:`LogRecord`."
msgstr ""

#: ../Doc/library/logging.rst:939
msgid ""
"This function has been provided, along with :func:`setLogRecordFactory`, to "
"allow developers more control over how the :class:`LogRecord` representing a "
"logging event is constructed."
msgstr ""

#: ../Doc/library/logging.rst:944
msgid ""
"See :func:`setLogRecordFactory` for more information about the how the "
"factory is called."
msgstr ""

#: ../Doc/library/logging.rst:949
msgid ""
"Logs a message with level :const:`DEBUG` on the root logger. The *msg* is "
"the message format string, and the *args* are the arguments which are merged "
"into *msg* using the string formatting operator. (Note that this means that "
"you can use keywords in the format string, together with a single dictionary "
"argument.)"
msgstr ""

#: ../Doc/library/logging.rst:954
msgid ""
"There are three keyword arguments in *kwargs* which are inspected: "
"*exc_info* which, if it does not evaluate as false, causes exception "
"information to be added to the logging message. If an exception tuple (in "
"the format returned by :func:`sys.exc_info`) or an exception instance is "
"provided, it is used; otherwise, :func:`sys.exc_info` is called to get the "
"exception information."
msgstr ""

#: ../Doc/library/logging.rst:980
msgid ""
"The third optional keyword argument is *extra* which can be used to pass a "
"dictionary which is used to populate the __dict__ of the LogRecord created "
"for the logging event with user-defined attributes. These custom attributes "
"can then be used as you like. For example, they could be incorporated into "
"logged messages. For example::"
msgstr ""

#: ../Doc/library/logging.rst:991
msgid "would print something like:"
msgstr ""

#: ../Doc/library/logging.rst:1001
msgid ""
"If you choose to use these attributes in logged messages, you need to "
"exercise some care. In the above example, for instance, the :class:"
"`Formatter` has been set up with a format string which expects 'clientip' "
"and 'user' in the attribute dictionary of the LogRecord. If these are "
"missing, the message will not be logged because a string formatting "
"exception will occur. So in this case, you always need to pass the *extra* "
"dictionary with these keys."
msgstr ""

#: ../Doc/library/logging.rst:1020
msgid ""
"Logs a message with level :const:`INFO` on the root logger. The arguments "
"are interpreted as for :func:`debug`."
msgstr ""

#: ../Doc/library/logging.rst:1026
msgid ""
"Logs a message with level :const:`WARNING` on the root logger. The arguments "
"are interpreted as for :func:`debug`."
msgstr ""

#: ../Doc/library/logging.rst:1029
msgid ""
"There is an obsolete function ``warn`` which is functionally identical to "
"``warning``. As ``warn`` is deprecated, please do not use it - use "
"``warning`` instead."
msgstr ""

#: ../Doc/library/logging.rst:1036
msgid ""
"Logs a message with level :const:`ERROR` on the root logger. The arguments "
"are interpreted as for :func:`debug`."
msgstr ""

#: ../Doc/library/logging.rst:1042
msgid ""
"Logs a message with level :const:`CRITICAL` on the root logger. The "
"arguments are interpreted as for :func:`debug`."
msgstr ""

#: ../Doc/library/logging.rst:1048
msgid ""
"Logs a message with level :const:`ERROR` on the root logger. The arguments "
"are interpreted as for :func:`debug`. Exception info is added to the logging "
"message. This function should only be called from an exception handler."
msgstr ""

#: ../Doc/library/logging.rst:1054
msgid ""
"Logs a message with level *level* on the root logger. The other arguments "
"are interpreted as for :func:`debug`."
msgstr ""

#: ../Doc/library/logging.rst:1057
msgid ""
"The above module-level convenience functions, which delegate to the root "
"logger, call :func:`basicConfig` to ensure that at least one handler is "
"available. Because of this, they should *not* be used in threads, in "
"versions of Python earlier than 2.7.1 and 3.2, unless at least one handler "
"has been added to the root logger *before* the threads are started. In "
"earlier versions of Python, due to a thread safety shortcoming in :func:"
"`basicConfig`, this can (under rare circumstances) lead to handlers being "
"added multiple times to the root logger, which can in turn lead to multiple "
"messages for the same event."
msgstr ""

#: ../Doc/library/logging.rst:1069
msgid ""
"Provides an overriding level *level* for all loggers which takes precedence "
"over the logger's own level. When the need arises to temporarily throttle "
"logging output down across the whole application, this function can be "
"useful. Its effect is to disable all logging calls of severity *level* and "
"below, so that if you call it with a value of INFO, then all INFO and DEBUG "
"events would be discarded, whereas those of severity WARNING and above would "
"be processed according to the logger's effective level. If ``logging."
"disable(logging.NOTSET)`` is called, it effectively removes this overriding "
"level, so that logging output again depends on the effective levels of "
"individual loggers."
msgstr ""

#: ../Doc/library/logging.rst:1080
msgid ""
"Note that if you have defined any custom logging level higher than "
"``CRITICAL`` (this is not recommended), you won't be able to rely on the "
"default value for the *level* parameter, but will have to explicitly supply "
"a suitable value."
msgstr ""

#: ../Doc/library/logging.rst:1085
msgid ""
"The *level* parameter was defaulted to level ``CRITICAL``. See Issue #28524 "
"for more information about this change."
msgstr ""

#: ../Doc/library/logging.rst:1091
msgid ""
"Associates level *level* with text *levelName* in an internal dictionary, "
"which is used to map numeric levels to a textual representation, for example "
"when a :class:`Formatter` formats a message. This function can also be used "
"to define your own levels. The only constraints are that all levels used "
"must be registered using this function, levels should be positive integers "
"and they should increase in increasing order of severity."
msgstr ""

#: ../Doc/library/logging.rst:1098
msgid ""
"If you are thinking of defining your own levels, please see the section on :"
"ref:`custom-levels`."
msgstr ""

#: ../Doc/library/logging.rst:1103
#, python-format
msgid ""
"Returns the textual representation of logging level *level*. If the level is "
"one of the predefined levels :const:`CRITICAL`, :const:`ERROR`, :const:"
"`WARNING`, :const:`INFO` or :const:`DEBUG` then you get the corresponding "
"string. If you have associated levels with names using :func:`addLevelName` "
"then the name you have associated with *level* is returned. If a numeric "
"value corresponding to one of the defined levels is passed in, the "
"corresponding string representation is returned. Otherwise, the string "
"'Level %s' % level is returned."
msgstr ""

#: ../Doc/library/logging.rst:1111
#, python-format
msgid ""
"Levels are internally integers (as they need to be compared in the logging "
"logic). This function is used to convert between an integer level and the "
"level name displayed in the formatted log output by means of the ``"
"%(levelname)s`` format specifier (see :ref:`logrecord-attributes`)."
msgstr ""

#: ../Doc/library/logging.rst:1116
msgid ""
"In Python versions earlier than 3.4, this function could also be passed a "
"text level, and would return the corresponding numeric value of the level. "
"This undocumented behaviour was considered a mistake, and was removed in "
"Python 3.4, but reinstated in 3.4.2 due to retain backward compatibility."
msgstr ""

#: ../Doc/library/logging.rst:1124
msgid ""
"Creates and returns a new :class:`LogRecord` instance whose attributes are "
"defined by *attrdict*. This function is useful for taking a pickled :class:"
"`LogRecord` attribute dictionary, sent over a socket, and reconstituting it "
"as a :class:`LogRecord` instance at the receiving end."
msgstr ""

#: ../Doc/library/logging.rst:1132
msgid ""
"Does basic configuration for the logging system by creating a :class:"
"`StreamHandler` with a default :class:`Formatter` and adding it to the root "
"logger. The functions :func:`debug`, :func:`info`, :func:`warning`, :func:"
"`error` and :func:`critical` will call :func:`basicConfig` automatically if "
"no handlers are defined for the root logger."
msgstr ""

#: ../Doc/library/logging.rst:1138
msgid ""
"This function does nothing if the root logger already has handlers "
"configured, unless the keyword argument *force* is set to ``True``."
msgstr ""

#: ../Doc/library/logging.rst:1141
msgid ""
"This function should be called from the main thread before other threads are "
"started. In versions of Python prior to 2.7.1 and 3.2, if this function is "
"called from multiple threads, it is possible (in rare circumstances) that a "
"handler will be added to the root logger more than once, leading to "
"unexpected results such as messages being duplicated in the log."
msgstr ""

#: ../Doc/library/logging.rst:1148
msgid "The following keyword arguments are supported."
msgstr ""

#: ../Doc/library/logging.rst:1155
msgid "*filename*"
msgstr ""

#: ../Doc/library/logging.rst:1155
msgid ""
"Specifies that a FileHandler be created, using the specified filename, "
"rather than a StreamHandler."
msgstr ""

#: ../Doc/library/logging.rst:1159
msgid "*filemode*"
msgstr ""

#: ../Doc/library/logging.rst:1159
msgid ""
"If *filename* is specified, open the file in this :ref:`mode <filemodes>`. "
"Defaults to ``'a'``."
msgstr ""

#: ../Doc/library/logging.rst:1163
msgid "*format*"
msgstr ""

#: ../Doc/library/logging.rst:1163
msgid "Use the specified format string for the handler."
msgstr ""

#: ../Doc/library/logging.rst:1166
msgid "*datefmt*"
msgstr ""

#: ../Doc/library/logging.rst:1166
msgid ""
"Use the specified date/time format, as accepted by :func:`time.strftime`."
msgstr ""

#: ../Doc/library/logging.rst:1169
msgid "*style*"
msgstr ""

#: ../Doc/library/logging.rst:1169
msgid ""
"If *format* is specified, use this style for the format string. One of "
"``'%'``, ``'{'`` or ``'$'`` for :ref:`printf-style <old-string-"
"formatting>`, :meth:`str.format` or :class:`string.Template` respectively. "
"Defaults to ``'%'``."
msgstr ""

#: ../Doc/library/logging.rst:1177
msgid "*level*"
msgstr ""

#: ../Doc/library/logging.rst:1177
msgid "Set the root logger level to the specified :ref:`level <levels>`."
msgstr ""

#: ../Doc/library/logging.rst:1180
msgid "*stream*"
msgstr ""

#: ../Doc/library/logging.rst:1180
msgid ""
"Use the specified stream to initialize the StreamHandler. Note that this "
"argument is incompatible with *filename* - if both are present, a "
"``ValueError`` is raised."
msgstr ""

#: ../Doc/library/logging.rst:1185
msgid "*handlers*"
msgstr ""

#: ../Doc/library/logging.rst:1185
msgid ""
"If specified, this should be an iterable of already created handlers to add "
"to the root logger. Any handlers which don't already have a formatter set "
"will be assigned the default formatter created in this function. Note that "
"this argument is incompatible with *filename* or *stream* - if both are "
"present, a ``ValueError`` is raised."
msgstr ""

#: ../Doc/library/logging.rst:1194
msgid "*force*"
msgstr ""

#: ../Doc/library/logging.rst:1194
msgid ""
"If this keyword argument is specified as true, any existing handlers "
"attached to the root logger are removed and closed, before carrying out the "
"configuration as specified by the other arguments."
msgstr ""

#: ../Doc/library/logging.rst:1201
msgid "The *style* argument was added."
msgstr ""

#: ../Doc/library/logging.rst:1204
msgid ""
"The *handlers* argument was added. Additional checks were added to catch "
"situations where incompatible arguments are specified (e.g. *handlers* "
"together with *stream* or *filename*, or *stream* together with *filename*)."
msgstr ""

#: ../Doc/library/logging.rst:1210
msgid "The *force* argument was added."
msgstr ""

#: ../Doc/library/logging.rst:1215
msgid ""
"Informs the logging system to perform an orderly shutdown by flushing and "
"closing all handlers. This should be called at application exit and no "
"further use of the logging system should be made after this call."
msgstr ""

#: ../Doc/library/logging.rst:1219
msgid ""
"When the logging module is imported, it registers this function as an exit "
"handler (see :mod:`atexit`), so normally there's no need to do that manually."
msgstr ""

#: ../Doc/library/logging.rst:1226
msgid ""
"Tells the logging system to use the class *klass* when instantiating a "
"logger. The class should define :meth:`__init__` such that only a name "
"argument is required, and the :meth:`__init__` should call :meth:`Logger."
"__init__`. This function is typically called before any loggers are "
"instantiated by applications which need to use custom logger behavior. After "
"this call, as at any other time, do not instantiate loggers directly using "
"the subclass: continue to use the :func:`logging.getLogger` API to get your "
"loggers."
msgstr ""

#: ../Doc/library/logging.rst:1237
msgid "Set a callable which is used to create a :class:`LogRecord`."
msgstr ""

#: ../Doc/library/logging.rst:1239
msgid "The factory callable to be used to instantiate a log record."
msgstr ""

#: ../Doc/library/logging.rst:1241
msgid ""
"This function has been provided, along with :func:`getLogRecordFactory`, to "
"allow developers more control over how the :class:`LogRecord` representing a "
"logging event is constructed."
msgstr ""

#: ../Doc/library/logging.rst:1246
msgid "The factory has the following signature:"
msgstr ""

#: ../Doc/library/logging.rst:1248
msgid ""
"``factory(name, level, fn, lno, msg, args, exc_info, func=None, sinfo=None, "
"**kwargs)``"
msgstr ""

#: ../Doc/library/logging.rst:1250
msgid "The logger name."
msgstr ""

#: ../Doc/library/logging.rst
msgid "level"
msgstr ""

#: ../Doc/library/logging.rst:1251
msgid "The logging level (numeric)."
msgstr ""

#: ../Doc/library/logging.rst
msgid "fn"
msgstr ""

#: ../Doc/library/logging.rst:1252
msgid "The full pathname of the file where the logging call was made."
msgstr ""

#: ../Doc/library/logging.rst
msgid "lno"
msgstr ""

#: ../Doc/library/logging.rst:1253
msgid "The line number in the file where the logging call was made."
msgstr ""

#: ../Doc/library/logging.rst:1254
msgid "The logging message."
msgstr ""

#: ../Doc/library/logging.rst:1255
msgid "The arguments for the logging message."
msgstr ""

#: ../Doc/library/logging.rst:1256
msgid "An exception tuple, or ``None``."
msgstr ""

#: ../Doc/library/logging.rst
msgid "func"
msgstr ""

#: ../Doc/library/logging.rst:1257
msgid "The name of the function or method which invoked the logging call."
msgstr ""

#: ../Doc/library/logging.rst
msgid "sinfo"
msgstr ""

#: ../Doc/library/logging.rst:1259
msgid ""
"A stack traceback such as is provided by :func:`traceback.print_stack`, "
"showing the call hierarchy."
msgstr ""

#: ../Doc/library/logging.rst
msgid "kwargs"
msgstr ""

#: ../Doc/library/logging.rst:1261
msgid "Additional keyword arguments."
msgstr ""

#: ../Doc/library/logging.rst:1265
msgid "Module-Level Attributes"
msgstr ""

#: ../Doc/library/logging.rst:1269
msgid ""
"A \"handler of last resort\" is available through this attribute. This is a :"
"class:`StreamHandler` writing to ``sys.stderr`` with a level of ``WARNING``, "
"and is used to handle logging events in the absence of any logging "
"configuration. The end result is to just print the message to ``sys."
"stderr``. This replaces the earlier error message saying that \"no handlers "
"could be found for logger XYZ\". If you need the earlier behaviour for some "
"reason, ``lastResort`` can be set to ``None``."
msgstr ""

#: ../Doc/library/logging.rst:1280
msgid "Integration with the warnings module"
msgstr ""

#: ../Doc/library/logging.rst:1282
msgid ""
"The :func:`captureWarnings` function can be used to integrate :mod:`logging` "
"with the :mod:`warnings` module."
msgstr ""

#: ../Doc/library/logging.rst:1287
msgid ""
"This function is used to turn the capture of warnings by logging on and off."
msgstr ""

#: ../Doc/library/logging.rst:1290
msgid ""
"If *capture* is ``True``, warnings issued by the :mod:`warnings` module will "
"be redirected to the logging system. Specifically, a warning will be "
"formatted using :func:`warnings.formatwarning` and the resulting string "
"logged to a logger named ``'py.warnings'`` with a severity of :const:"
"`WARNING`."
msgstr ""

#: ../Doc/library/logging.rst:1295
msgid ""
"If *capture* is ``False``, the redirection of warnings to the logging system "
"will stop, and warnings will be redirected to their original destinations (i."
"e. those in effect before ``captureWarnings(True)`` was called)."
msgstr ""

#: ../Doc/library/logging.rst:1303
msgid "Module :mod:`logging.config`"
msgstr ""

#: ../Doc/library/logging.rst:1303
msgid "Configuration API for the logging module."
msgstr ""

#: ../Doc/library/logging.rst:1306
msgid "Module :mod:`logging.handlers`"
msgstr ""

#: ../Doc/library/logging.rst:1306
msgid "Useful handlers included with the logging module."
msgstr ""

#: ../Doc/library/logging.rst:1310
msgid ":pep:`282` - A Logging System"
msgstr ""

#: ../Doc/library/logging.rst:1309
msgid ""
"The proposal which described this feature for inclusion in the Python "
"standard library."
msgstr ""

#: ../Doc/library/logging.rst:1315
msgid ""
"`Original Python logging package <https://www.red-dove.com/python_logging."
"html>`_"
msgstr ""

#: ../Doc/library/logging.rst:1313
msgid ""
"This is the original source for the :mod:`logging` package.  The version of "
"the package available from this site is suitable for use with Python 1.5.2, "
"2.1.x and 2.2.x, which do not include the :mod:`logging` package in the "
"standard library."
msgstr ""
